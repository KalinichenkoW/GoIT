"""
Модуль 10: Основи роботи з класамиДомашнє завдання
Домашнє завдання
Завдання
У цій домашній роботі ми продовжимо розвивати нашого віртуального асистента з CLI інтерфейсом.

Наш асистент вже вміє взаємодіяти з користувачем за допомогою командного рядка, отримуючи команди 
та аргументи, та виконуючи потрібні дії. У цьому завданні потрібно буде попрацювати над внутрішньою
логікою асистента, над тим, як зберігаються дані, які саме дані і що з ними можна зробити.

Застосуємо для цих цілей об'єктно-орієнтоване програмування. Спершу виділимо декілька сутностей
(моделей), з якими працюватимемо.

У користувача буде адресна книга або книга контактів. Ця книга контактів містить записи.
Кожен запис містить деякий набір полів.

Таким чином ми описали сутності (класи), які необхідно реалізувати. Далі розглянемо вимоги 
до цих класів та встановимо їх взаємозв'язок, правила, за якими вони будуть взаємодіяти.

Користувач взаємодіє з книгою контактів, додаючи, видаляючи та редагуючи записи. 
Також користувач повинен мати можливість шукати в книзі контактів записи за одним або кількома критеріями (полями).

Про поля також можна сказати, що вони можуть бути обов'язковими (ім'я) 
та необов'язковими (телефон або email наприклад). Також записи можуть містити 
декілька полів одного типу (декілька телефонів наприклад). 
Користувач повинен мати можливість додавати/видаляти/редагувати поля у будь-якому записі.

В цій домашній роботі ви повинні реалізувати такі класи:

Клас AddressBook, який наслідується від UserDict, та ми потім додамо логіку пошуку за 
записами до цього класу.
Клас Record, який відповідає за логіку додавання/видалення/редагування 
необов'язкових полів та зберігання
обов'язкового поля Name.
Клас Field, який буде батьківським для всіх полів, у ньому потім реалізуємо логіку, загальну для всіх полів.
Клас Name, обов'язкове поле з ім'ям.
Клас Phone, необов'язкове поле з телефоном та таких один запис (Record) може містити кілька.

Реалізовано всі класи із завдання.
Записи Record в AddressBook зберігаються як значення у словнику. Як ключі використовується значення Record.name.value.
Record зберігає об'єкт Name в окремому атрибуті.
Record зберігає список об'єктів Phone в окремому атрибуті.
Record реалізує методи для додавання/видалення/редагування об'єктів Phone.
AddressBook реалізує метод add_record, який додає Record у self.data.

Модуль 11: 'Магічні' методиДомашнє завдання
Домашнє завдання
Завдання
У цьому домашньому завданні ми:

Додамо поле для дня народження Birthday. Це поле не обов'язкове, але може бути тільки одне.
Додамо функціонал роботи з Birthday у клас Record, а саме функцію days_to_birthday,
яка повертає кількість днів до наступного дня народження.
Додамо функціонал перевірки на правильність наведених значень для полів Phone, Birthday.
Додамо пагінацію (посторінкове виведення) для AddressBook для ситуацій, коли книга дуже велика 
і потрібно показати вміст частинами, а не все одразу. 
Реалізуємо це через створення ітератора за записами.

Критерії приймання:
AddressBook реалізує метод iterator, який повертає генератор за записами AddressBook
і за одну ітерацію повертає представлення для N записів.
Клас Record приймає ще один додатковий (опціональний) аргумент класу Birthday
Клас Record реалізує метод days_to_birthday, який повертає кількість днів 
до наступного дня народження контакту, якщо день народження заданий.
setter та getter логіку для атрибутів value спадкоємців Field.
Перевірку на коректність веденого номера телефону setter для value класу Phone.
Перевірку на коректність веденого дня народження setter для value класу Birthday.
"""
from collections import UserDict
from datetime import datetime, timedelta, date


# Клас Field, який буде батьківським для всіх полів,
# у ньому потім реалізуємо логіку, загальну для всіх полів.
class Field:
    def __init__(self, value):
        self.value = value


# Клас Name, обов'язкове поле з ім'ям.
class Name(Field):
    pass


# Клас Phone, необов'язкове поле з телефоном та таких один запис (Record) # може містити кілька.
class Phone(Field):
    pass


# Клас Mail, необов'язкове поле з e-mail та таких один запис (Record) # може містити кілька
class Mail(Field):
    pass


class Birthday(Field):
    pass


# Клас Record, який відповідає за логіку додавання/видалення/редагування
# необов'язкових полів та зберігання обов'язкового поля Name.
class Record:
    def __init__(self, name: str, phones: list, emails: list, birthday: date):
        self.name = name
        self.phones = [Phone(phone) for phone in phones]
        self.emails = [Mail(email) for email in emails]  # emails
        self.birthday = birthday

    # повертає кількість днів до наступного дня народження.
    def days_to_birthday(self, birthday):
        pass
        # current_date = date.today()

    def add_phone(self, phone):
        phone_number = Phone(phone)
        if phone_number not in self.phones:
            self.phones.append(phone_number)

    def find_phone(self, value):
        pass

    def delete_phone(self, phone):
        self.phones.remove(phone)

    def edit_phone(self, old_phone, new_phone):
        index = self.phones.index(old_phone)
        self.phones[index] = new_phone


# Клас AddressBook, який наслідується від UserDict,
# та ми потім додамо логіку пошуку за записами до цього класу.
class AddressBook(UserDict):
    MAX_VALUE = 5

    def __init__(self):
        self.current_value = 0

    def add_record(self, record: Record):
        self.data[record.name.value] = record

    def find_record(self, value):
        return self.data.get(value)

    def __iter__(self):
        return self

    def __next__(self):
        if self.current_value < self.MAX_VALUE:
            self.current_value += 1
            return self
        raise StopIteration


# -----------------------------------------------
# як то кажуть, працює для основних вимог і того достаньо((((
# Але, такий код не відповідає мінімальним вимогам реального програмування.
# І ось лише деякі зауваження
# ----------------------------
# стосується кожного класу
# class Phone(Field):
#     phone = []  -- навіщо?
#     def __init__(self, phone): - навіщо в такому разі наслідування від field?
#         self.phone = phone
# --------------------------
# def __init__(self, name: str, *phones: list, **emails: list):
# ви кажете що emails це ліст( але ** - означає що іменовані аргументи невизначеної кількості
# - а іменовані аргументи це ім'я та значення - і це відповідає словнику
# -----------
# phone_number = Phone(phone)
#         if phone_number not in self.phones: - не спрацює  без додаткової логіки у класі phone
#           - тому що кожен екземпляр навіть з однаковими значення - це різні сутсності
# ---------------
#  index = self.phones.index(old_number) - у вас буде завжди помилка ValueError за тієїж
# причина що і в попередній проблемі
# -----------
# self.phones.remove(phone) - вам треба об додавати саме той об'єкт який є у списку або у
# вас буде помилка за тієїж причина що і в попередній проблемі
# ------------------------
# Якщо бажаєте ознаймитися докладніше з зауваженнями - пишіть у слак
# -------------
# Додам на жаль, рекомендації для перевірки кода, перевіряють лише одиничне додавання
# запису і все((((
# -----------------------------------------------------


# Mentor
# Для ДЗ 10 рекомендую в код додати наступні тести, при корректній реалізації ДЗ - вони повинні успішно пройти
# if name == "main":
# name = Name("Bill")
# phone = Phone("1234567890")
# email = Mail("mail@ukr.ua")
# rec = Record(name)
# ab = AddressBook()
# ab.add_record(rec)
# assert isinstance(ab['Bill'], Record)
# assert isinstance(ab['Bill'].name, Name)
# assert isinstance(ab['Bill'].phones, list)
# assert isinstance(ab['Bill'].phones[0], Phone)
# assert ab['Bill'].phones[0].value == '1234567890'
# print('All Ok)')
